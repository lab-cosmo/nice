#!/usr/bin/python3

import pickle
import json
import sys, os, argparse
import ase.io as ase_io
import numpy as np
from nice.transformers import *
from nice.rascal_coefficients import get_rascal_coefficients_parallelized


def main():
    """
    Command-line utility to optimize the parameters of NICE features. 
    Will output a pickled model which can then be used to predict features.    
    """

    # Tweak the autogenerated help output to look nicer
    formatter = lambda prog: argparse.HelpFormatter(prog, max_help_position=22)
    parser = argparse.ArgumentParser(description=main.__doc__, formatter_class=formatter)
    
    parser.add_argument('input', type=str, default="", nargs="?",
                        help='XYZ file to load')
    parser.add_argument('-o', '--output', type=str, default="",
                        help='Output files prefix. Defaults to input filename with stripped extension')
    parser.add_argument('--select', type=str, default=":",
                        help='Selection of input frames. ASE format.')
    parser.add_argument('--nmax', type=int, default=6,
                        help='Number of radial channels')
    parser.add_argument('--lmax', type=int, default=4,
                        help='Number of angular momentum channels')
    parser.add_argument('--rcut', type=float, default=4,
                        help='Radial cut off')
    parser.add_argument('--sigma', type=float, default=0.5,
                        help='Gaussian smearing')
    parser.add_argument('--json', type=str, default='{}', help='Additional hypers, as JSON string')
    parser.add_argument('--mask-id', type=int, default=-1,
                        help='Central atom it to be selected')
    parser.add_argument('--mask', type=str, default="",
                        help='Central atom type to be selected')
    parser.add_argument('--screen', type=int, default=1000,
                        help='Target number of equivariants to be computed in the iteration step')
    parser.add_argument('--screen0', type=int, default=500,
                        help='Target number of invariants to be computed in the iteration step')   
    parser.add_argument('--nsph', type=int, default=0,
                        help='Target number of spherical expansion coefficients to keep. 0 defaults all')                                             
    parser.add_argument('--keep', type=int, default=200,
                        help='Target number of equivariants to be contracted to')
    parser.add_argument('--keep0', type=int, default=400,
                        help='Target number of invariants to be stored')
                        

    args = parser.parse_args()

    filename = args.input
    output = args.output
    select = args.select
    nmax = args.nmax
    lmax = args.lmax
    rcut = args.rcut
    gs = args.sigma
    mask = args.mask
    mask_id = args.mask_id
    nsph = args.nsph
    fkeep = args.keep
    fkeep0 = args.keep0
    fscreen = args.screen
    fscreen0 = args.screen0
    json_hypers = json.loads(args.json)
    pcond = 1e-4
    
    if output == "":
        output = os.path.splitext(filename)[0]
        
   
    # first-order equivariants are just combinations of the spherical coefficients
    blocklist = [ StandardBlock(ThresholdExpansioner(),
                                CovariantsPurifierBoth(nsph),
                                IndividualLambdaPCAsBoth(nsph),
                                None, None, None) ];
    # ~ numax=4;
    # ~ for nu in range(1, numax-1):
        # ~ blocklist.append(
            # ~ StandardBlock(ThresholdExpansioner(num_expand=fscreen),
                         # ~ CovariantsPurifierBoth(),
                         # ~ IndividualLambdaPCAsBoth(n_components=fkeep),
                         # ~ ThresholdExpansioner(num_expand=fscreen0, mode='invariants'),
                         # ~ InvariantsPurifier(),
                         # ~ InvariantsPCA(n_components=fkeep0)) 
                         # ~ )
    # ~ # at the last order, we only need invariants
    # ~ blocklist.append(
            # ~ StandardBlock(None, None, None,
                         # ~ ThresholdExpansioner(num_expand=fscreen0, mode='invariants'),
                         # ~ InvariantsPurifier(),
                         # ~ InvariantsPCA(n_components=fkeep0)) 
                         # ~ )
    
    nice_sequence = StandardSequence(blocklist)

    print("Loading structures ", filename, " frames: ", select)
    frames = ase_io.read(filename, index=select)
    for f in frames:
        if f.cell.sum() == 0.0:  # fake PBC
            f.cell = [100,100,100]
            f.positions += np.asarray([50,50,50])
        f.pbc = True
        f.wrap(eps=1e-12)
    
    print("Computing spherical expansion")

    hypers = { **{
        'interaction_cutoff': rcut,
        'max_radial': nmax,
        'max_angular': lmax,
        'gaussian_sigma_constant': gs,
        'gaussian_sigma_type': 'Constant',
        'cutoff_smooth_width': 0.5,
        'radial_basis': 'GTO'
    }, **json_hypers }
       
    feats = get_rascal_coefficients_parallelized(frames, hypers, mask=(None if mask=="" else mask), mask_id=(None if mask_id<0 else mask_id))    
    # merge all the coefficients, as we want (for some reason) to apply the same NICE to all species. if mask has been specified, this does nothing
    l = []
    for f in feats.values():
        l.append(f)
    feats = np.vstack(l)    
    if nsph == 0:
        nsph = feats.shape[1]        
    scale = 1.0/np.sqrt(np.sum(feats**2)/len(feats));
    feats *= scale   # normalization of features
    
    print("FEATS ", feats.shape)
    
    hypers["keep"] = fkeep
    hypers["keep0"] = fkeep0
    hypers["screen"] = fscreen
    hypers["screen0"] = fscreen0            
    hypers["pcond"] = pcond    
    hypers["reference-file"] = filename
    hypers["reference-sel"] = select
    hypers["reference-mask"] = mask
    hypers["reference-mask-id"] = mask_id            
    hypers["scale"] = scale
    hypers["nsph"] = nsph    
        
    print("Precomputing CG coefficients")
    cglist = ClebschGordan(args.lmax)
        
    print("Optimizing NICE")
    nice_sequence.fit(feats, clebsch_gordan = cglist)
    
    print("Dumping NICE model")    
    pickle.dump( { 
               "HYPERS" : hypers, 
               "NICE": nice_sequence,
             }, open(output+".pickle", "wb"))
    
    #np.save(output+"-inv", np.hstack([rhoinv1, rhoinv2, rhoinv3, rhoinv4, rhoinv5]) )
    
if __name__ == '__main__':
    main()

